use crate::types::*;
use serde_json;
use toybox_core;
use toybox_core::{
    AleAction,
    graphics::Drawable,
    QueryError
};

impl Default for $CLASSNAME { 
    fn default() -> Self {
        $CLASSNAME {}
    }
}

// you will want to remove this; it is a temporary solution
// to get the autogenerated code to compile.
impl Default for StateCore {
    fn default() -> Self {
        StateCore {
            score: -1,
            lives: -1, 
            level: -1
        }
    }
}

impl toybox_core::Simulation for $CLASSNAME {
    /// Seed simulation.
    fn reset_seed(&mut self, seed: u32) {
        // Implement this if your game has randomness.
        // This is typically done by adding a field onto the $CLASSNAME struct
    }

    /// Generate a new State. This is in a Box<State> because it may be 1 of many unknown types as far as calling code is concerned.
    fn new_game(&mut self) -> Box<dyn toybox_core::State> {
        Box::new(State {
            config: self.clone(),
            state: StateCore::default(),
        }
    }

    /// Generate a new State from JSON String (usually modified from a dump of State::to_json).
    fn new_state_from_json(&self, json: &str) -> Result<Box<dyn toybox_core::State>, serde_json::Error> {
        let state: StateCore = serde_json::from_str(json)?;
        Ok(Box::new(State {
            config: self.clone(),
            state
        }))
    }

    /// Return a tuple of game size in pixels, e.g., (100,100).
    fn game_size(&self) -> (i32, i32) {
        // update this as needed
        (100, 100)
    }

    /// This serializes the "config" for a game to json.
    fn to_json(&self) -> String {
        serde_json::to_string(&self.state).expect("Should be no JSON Serialization Errors.")
    }

    /// This deserializes the "config" for a game from json.
    /// Generate new state and new config from JSON String.
    fn from_json(&self, json: &str) -> Result<Box<dyn toybox_core::Simulation>, serde_json::Error> {
        let config: $CLASSNAME = serde_json::from_str(json)?;
        Ok(Box::new(config))

    }

    /// Legal action set:
    fn legal_action_set(&self) -> Vec<AleAction> {
        // Update this; you may want to use ALE actions. See 
        // other games for examples.
        vec![]
    }

    /// Getter for JSON Schema for this game's state.
    fn schema_for_state(&self) -> String {
        let schema = schema_for!(StateCore);
        serde_json::to_string(&schema).expect("JSONSchema should be flawless.")
    }

    /// Getter for JSON Schema for this game's config.
    fn schema_for_config(&self) -> String {
        let schema = schema_for!($CLASSNAME);
        serde_json::to_string(&schema).expect("JSONSchema should be flawless.")
    }

}

impl toybox_core::State for State {
    /// When < 0, this state should be replaced with a call to new_game() on the simulation.
    fn lives(&self) -> i32 {
        -1
    }
    /// Get the score from the game, i32 allows for negative scores.
    fn score(&self) -> i32 {
        -1
    }
    /// Get the level from the game.
    fn level(&self) -> i32 {
        -1
    }
    /// To update internally to the next state, we pass buttons to internal logic.
    fn update_mut(&mut self, buttons: toybox_core::Input) {

    }
    /// Any state can create a vector of drawable objects to present itself.
    fn draw(&self) -> Vec<Drawable> {
        Vec::new()
    }
    /// Any state can serialize to JSON String.
    fn to_json(&self) -> String {
        String::new()
    }
    /// Copy this state to save it for later.
    fn copy(&self) -> Box<dyn toybox_core::State> {
        Box::new(self.clone())
    }
    /// Submit a query to this state object, returning a JSON String or error message.
    fn query_json(&self, query: &str, args: &serde_json::Value) -> Result<String, QueryError> {
        Ok("TODO".to_string())
    }
}